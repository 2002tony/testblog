{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/2021-11-22-Algorithm_bronze_chapter1-1/","result":{"data":{"site":{"siteMetadata":{"title":"KunheeKim.dev","author":"[Kunhee Kim]","siteUrl":"https://kunheekimdev.github.io","comment":{"disqusShortName":"","utterances":"kunheekimdev/kunheekimdev.github.io"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"c14df5c3-67e0-5654-8ead-f73ecd9338a9","excerpt":"공부 자료 (링크) 1. 시간 복잡도의 필요성 대부분의 프로그래밍 문제에서는 문제의 채점 제한 시간이 주어집니다. 컴퓨터의 연산 속도는 한정적이기 때문에, 주어진 시간 내에 문제를 해결하기 위해서는 컴퓨터가 몇 번의 연산까지 수행할 수 있는지를 생각하며 문제를 풀어야 합니다. 대부분의 채점 서버에서는 초당 10^8 번까지의 연산을 수행할 수 있습니다.이를 토대로, 주어진 입력값에 대한 최대 연산 회수가 제한 시간 내에 시행될 수 있는지를 염두에 두고 알고리즘을 선택하고 구성하여야 합니다.…","html":"<p><strong><u>공부 자료</u></strong> <a href=\"https://usaco.guide/bronze/time-comp?lang=cpp\">(링크)</a></p>\n<h2 id=\"1-시간-복잡도의-필요성\" style=\"position:relative;\"><a href=\"#1-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\" aria-label=\"1 시간 복잡도의 필요성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 시간 복잡도의 필요성</h2>\n<p>대부분의 프로그래밍 문제에서는 문제의 채점 제한 시간이 주어집니다. 컴퓨터의 연산 속도는 한정적이기 때문에, 주어진 시간 내에 문제를 해결하기 위해서는 컴퓨터가 몇 번의 연산까지 수행할 수 있는지를 생각하며 문제를 풀어야 합니다. 대부분의 채점 서버에서는 초당 10^8 번까지의 연산을 수행할 수 있습니다.이를 토대로, 주어진 입력값에 대한 최대 연산 회수가 제한 시간 내에 시행될 수 있는지를 염두에 두고 알고리즘을 선택하고 구성하여야 합니다.</p>\n<h2 id=\"2-시간-복잡도\" style=\"position:relative;\"><a href=\"#2-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"2 시간 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 시간 복잡도</h2>\n<p>시간 복잡도를 나타내기 위해서는 Big-O Notation 을 사용합니다. Big-O Notation은 주어진 변수 n 에 대하여 n에 대한 함수의 형태로 최악의 경우 몇 번의 연산이 필요한지를 나타냅니다. 아래의 여러 예시를 살펴보며 이해해봅시다.</p>\n<p>다음과 같은 코드는 한 번의 연산으로, O(1) 으로 표현되는 연산들입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">int a=3;\nint b=7;\nint c=a+b;</code></pre></div>\n<p>다음과 같은 반복문은 n번 반복되기 때문에 O(n) 으로 표현되는 연산들입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">for (int i = 0; i &lt; n; i++) {\n\t//단순 연산 (O(1))\n}</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">int i=0;\nwhile(i&lt;n){\n\t//단순 연산 (O(1))\n    i++;\n}</code></pre></div>\n<p>Big O notation을 통해 차수가 더 낮은 항들과 계수는 무시하기 때문에, 다음과 같은 예시들도 모두 O(n) 으로 표현되는 연산들입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">for (int i = 0; i &lt; 5 * n + 23; i++) {\n\t//단순 연산 (O(1))\n}</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">for (int i = 0; i &lt; n + 1557; i++) {\n\t//단순 연산 (O(1))\n}</code></pre></div>\n<p>다음과 같은 중첩 반복문은 두 반복문의 실행 회수를 곱하여 O(nm) 으로 표현되는 연산입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">for(int i=0; i&lt;n; i++){\n\tfor(int j=0; j&lt;m; j++){\n\t\t//단순 연산 (O(1))\n    }\n}</code></pre></div>\n<p>따라서, 다음과 같이 안쪽 반복문과 바깥쪽 반복문의 실행 회수가 같으면 O(n^2) 으로 표현됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">for(int i=0; i&lt;n; i++){\n\tfor(int j=0; j&lt;n; j++){\n\t\t//단순 연산 (O(1))\n    }\n}</code></pre></div>\n<p>여러 개의 반복문이 나타날 경우, 시간 복잡도는 그중 가장 많은 연산을 필요로 하는 반복문을 기준으로 합니다. 따라서, 다음과 같은 코드도 O(n^2) 으로 표현됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">for(int i=0; i&lt;n; i++){\n\tfor(int j=0; j&lt;n; j++){\n\t\t//단순 연산 (O(1))\n    }\n}\n\nfor (int i = 0; i &lt; n + 1557; i++) {\n\t//단순 연산 (O(1))\n}</code></pre></div>\n<p>다음과 같이 여러 반복문이 나타나지만 두 반복문이 서로 다른 변수에 비례할 경우, 두 반복문의 연산 회수를 더해 시간복잡도를 나타냅니다. 예를 들어, 다음과 같은 코드는 O(n^2+m) 으로 표현됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">for(int i=0; i&lt;n; i++){\n\tfor(int j=0; j&lt;n; j++){\n\t\t//단순 연산 (O(1))\n    }\n}\n\nfor (int i = 0; i &lt; m; i++) {\n\t//단순 연산 (O(1))\n}</code></pre></div>","frontmatter":{"title":"[Algorithm] Bronze 1-1. 시간복잡도(Time Complexity)","date":"November 22, 2021"}}},"pageContext":{"slug":"/algorithm/2021-11-22-Algorithm_bronze_chapter1-1/","previous":{"fields":{"slug":"/algorithm/2021-11-22-Algorithm_introduction/"},"frontmatter":{"title":"[Algorithm] 소개"}},"next":{"fields":{"slug":"/algorithm/2021-11-22-Algorithm_bronze_chapter1-2/"},"frontmatter":{"title":"[Algorithm] Bronze 1-2. Rectangle Geometry"}}}}}